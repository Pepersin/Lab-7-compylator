# 7laba
Тема лабораторной работы: Преобразование и анализ кода с использованием Clang и LLVM.  
Цель работы: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.  
Задание:   
1. Установить Clang и LLVM;  
2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;  
3. Использовать opt для применения базовой комплексной оптимизации (например, О2);  
4. Построить граф потока управления (CFG) для оптимизированной программы;  
5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы.

## Оглавление
[1. Установка и подготовка среды](#1-установка-и-подготовка-среды)  
[2. Исходный код](#2-исходный-код)  
[3. Получение AST](#3-получение-ast)  
[4. Генерация LLVM IR](#4-генерация-llvm-ir)  
[5. Оптимизация IR](#5-оптимизация-ir)  
[6. Граф потока управления программы](#6-граф-потока-управления-программы)  
[Вывод](#выводы)  
[Ответы на контрольные вопросы](#ответы-на-контрольные-вопросы)  

## Ход работы
### 1. Установка и подготовка среды
Работа выполнялась в среде Ubuntu 22.04.05.  
Команда установки:  
```
sudo apt install clang llvm

```
![image](https://github.com/user-attachments/assets/6b7a9f42-ca2d-4219-b9d0-6850102f7617)



Рисунок 1 - Установка компилятора clang и инструмента для анализа и оптимизации кода llvm.

### 2. Исходный код
![image](https://github.com/user-attachments/assets/01223c00-d2a6-45dc-bdd2-a8a7d09e9a4a)

Рисунок 2 - Исходный код в файле main.c.

### 3. Получение AST
Команда для получение абстрактного синтаксического дерева(AST):
```
clang -Xclang -ast-dump -fsyntax-only main.c
```
![image](https://github.com/user-attachments/assets/fb91e27d-ede1-41fd-998a-3cfed64d855d)
  
Рисунок 3 - Полученное AST файла main.c

### 4. Генерация LLVM IR
Команда для получения низкоуровневого промежуточного представления кода, которое используется компилятором Clang для оптимизаций и дальнейшей генерации машинного кода.:
```
clang -S -emit-llvm main.c -o main.ll
```
![image](https://github.com/user-attachments/assets/ddc30230-885c-489e-b4ff-9a77e1a36e21)
Рисунок 4 - Генерация файла main.ll, содержащий LLVM Intermediate Representation (IR) в текстовом формате.  

### 5. Оптимизация IR
Команда для генерирации LLVM IR в текстовом формате, но с отключёнными оптимизациями:
```
clang -O0 -S -emit-llvm main.c -o main_O0.ll
```
![image](https://github.com/user-attachments/assets/a471a996-f72b-4fb0-bd20-d84919175a36)
Рисунок 5 - Генерация LLVM IR файла main_O0.ll.  

Команда для генерирации LLVM IR в текстовом формате, но с комплексной оптимизацией среднего уровня:
Команда:
```
clang -O2 -S -emit-llvm main.c -o main_O2.ll
```
![75](https://github.com/user-attachments/assets/36befd3d-55d6-4d9f-bc16-a26eb2341aaf)  
Рисунок 6 - Генерация оптимизированного LLVM IR файла main_O2.ll.  

Команда для сравнения двух LLVM IR файлов:
```
diff main_O0.ll main_O2.ll
```
![image](https://github.com/user-attachments/assets/b5e2cf01-6227-4551-9c9d-53934b319818)
Рисунок 7 - Сравнение двух файлов main_O0.ll и main_O2.ll

### 6. Граф потока управления программы

Команда для генерации оптимизированного LLVM IR:
```bash
clang -O2 -S -emit-llvm main.c -o main.ll
```

Команда для генерации `.dot`-файлов CFG:
```bash
opt -passes=dot-cfg -disable-output main.ll
```
![image](https://github.com/user-attachments/assets/5656c703-bd1f-4907-a771-b4dee310b841)


Вывод:
```bash
find . -name "*.dot"
./.main.dot
./.square.dot
```

Создаются DOT-файлы:
- `.main.dot` — для функции `main`.
- `.square.dot` — для функции `square` (если не была удалена оптимизацией).

Команды для преобразования `.dot` в `.png`:
```bash
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .add.dot -o cfg_add.png
```

Команды для просмотра CFG:
```bash
xdg-open cfg_main.png
xdg-open cfg_add.png
```
![cfg_main](https://github.com/user-attachments/assets/4ac38506-7beb-4915-9322-678166e90a65)

![cfg_add](https://github.com/user-attachments/assets/2362e8cb-3712-4d5e-845c-63f424126dec)
● Промежуточное представление кода удобно для написания компиляторных трансформаций.  

## Ответы на контрольные вопросы
### 1. Что такое Clang, и какова его роль в процессе компиляции программ?  
Clang — это компилятор для C, C++ и Objective-C, часть LLVM. Он преобразует исходный код в машинный или промежуточный (IR), выполняя препроцессинг, анализ и оптимизацию.  

### 2. Что представляет собой LLVM и как он используется в современных компиляторах?  
LLVM — это модульная платформа для разработки компиляторов, использующая универсальное промежуточное представление (IR) для оптимизации и генерации машинного кода. В современных компиляторах (Clang, Rust, Swift) LLVM отвечает за анализ, оптимизацию и поддержку разных архитектур процессоров.  

### 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?  
AST отражает структуру исходного кода в виде дерева с узлами (операторы, выражения, объявления), сохраняя высокоуровневую семантику языка. LLVM IR — это низкоуровневое линейное представление, близкое к машинному коду, оптимизированное для анализа и преобразований (например, циклов или арифметики).  
Ключевое отличие: AST зависит от языка (C++, Rust и т.д.), а LLVM IR — универсален и используется для кросс-языковой оптимизации и генерации кода под разные процессоры.  

### 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?  
Промежуточное представление (IR) нужно, чтобы отделить анализ исходного кода от генерации машинного кода, упрощая поддержку новых языков и архитектур. Оно позволяет применять универсальные оптимизации до привязки к конкретному процессору. 

### 5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?  
**alloca** в LLVM IR выделяет память в стеке функции под локальные переменные и возвращает указатель на неё. Используется для хранения адресуемых данных. Автоматически освобождается при завершении функции, аналогично обычным стековым переменным в C.  

### 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?  
Оптимизация кода делает программу быстрее и компактнее, удаляя лишние операции и эффективнее используя ресурсы процессора. Главные задачи — ускорение вычислений, уменьшение размера кода и адаптация под конкретное оборудование. Без неё программы работали бы медленнее и тратили больше памяти.  

### 7. Что такое SSA-форма и почему она важна при оптимизации программ?  
SSA-форма (Static Single Assignment) — это представление программы, где каждая переменная инициализируется лишь единожды, что делает зависимости между данными явными и однозначными.  
Ключевая польза:  
Позволяет компилятору легко отслеживать поток данных, упрощая такие оптимизации, как удаление общих подвыражений и продвижение констант.  
Особенно полезна для анализа и преобразования циклов, где важно точно определять изменяемые переменные.  

### 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?  
Граф потока управления (CFG) — это визуальное представление структуры программы в виде связанных блоков кода, где каждый блок содержит последовательность инструкций, а стрелки между ними показывают возможные пути выполнения. Такой граф помогает компилятору анализировать и оптимизировать код, выявляя недостижимые участки, избыточные условия и потенциальные точки ветвления. Благодаря CFG можно эффективно применять оптимизации, связанные с анализом циклов, предсказанием переходов и распределением ресурсов.

### 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?  
В LLVM IR арифметические операции записываются как инструкции с явным указанием типа, например:  
%res = add i32 %a, %b.  
Каждая операция создаёт новое значение в SSA-форме, что упрощает анализ и оптимизацию кода.
Для умножения,сложения,вычитания и деления используются mul,add,sub,sdiv, а типы данных (как i32) всегда указываются явно, например: %sum = mul i32 %x, %y.  

### 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?  
Функции в LLVM IR являются самостоятельными единицами оптимизации, поскольку их изолированная структура позволяет применять преобразования локально, не анализируя всю программу. Это даёт возможность эффективно выполнять как внутрипроцедурные оптимизации, так и межпроцедурные (анализируя взаимодействия между функциями). Такой подход значительно ускоряет процесс компиляции и улучшает качество оптимизаций.  

### 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?  
Короткая функция в LLVM IR, вызываемая единожды, обычно подставляется на месте вызова и затем удаляется. Это устраняет накладные расходы на вызов.  

### 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?  
Использование LLVM IR и CFG даёт ключевые преимущества для автоматических оптимизаций по сравнению с анализом исходного C-кода:  
1. Абстракция от языка — IR унифицирует разные языки (C, C++, Rust и др.), позволяя применять общие оптимизации без привязки к синтаксису.  
2. Точный контроль потока — CFG явно показывает ветвления и циклы, упрощая анализ достижимости и удаление мёртвого кода.  
3. Низкоуровневые возможности — IR ближе к машинному коду, что позволяет оптимизировать даже «неочевидные» случаи (например, замену деления на сдвиги).   
Пример: На C компилятору сложно доказать, что цикл for (int i=0; i<10; i++) всегда выполнится 10 раз, а в IR это сразу видно в CFG и SSA-форме.

## Дополнительное задание (Вариант 9): 

Напишите функцию ```double average(int a, int b)``` и вызовите её из ```main()```. Постройте её CFG и определите, где можно провести оптимизации.

### 1. Установили компилятор GCC(необходим для компиляции C-программ)

![image](https://github.com/user-attachments/assets/f99beae2-ca1f-4e95-b44a-eaffd6ea67bc)

### 2. Создали в отдельной папке необходимые файлы, а именно average.h | average.c | main.c

![image](https://github.com/user-attachments/assets/d14dead4-ec93-4264-8a7f-3d5ad820b262)

### 3. Скомпилировали и запустили программу

![image](https://github.com/user-attachments/assets/495afb56-ef35-4628-b6ee-8fc01d53d308)

### 4. Постриол CFG

![image](https://github.com/user-attachments/assets/11972154-cf7f-4c3f-955c-d70de59f0f5b)


### 4. Возможные оптимизации

1) Избавиться от функции (inline)
Так как функция очень простая и состоит из одного выражения, можно объявить её как inline (или использовать макрос), чтобы компилятор вставлял код прямо в место вызова без накладных расходов на вызов функции.
```
inline double average(int a, int b) {
    return (a + b) / 2.0;
}
 ```
2) Использовать типы данных эффективно
Если a и b могут быть double, то лучше сразу использовать double параметры, чтобы не делать неявное преобразование. Это может ускорить работу, если вызывающая часть уже работает с double.
